var Spaces = (function (Ably) {
    'use strict';

    function _interopNamespaceDefault(e) {
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n.default = e;
        return Object.freeze(n);
    }

    var Ably__namespace = /*#__PURE__*/_interopNamespaceDefault(Ably);

    function typeOf(arg) {
        return Object.prototype.toString.call(arg).slice(8, -1);
    }
    // Equivalent of Util.isObject from ably-js
    function isObject(arg) {
        return typeOf(arg) === 'Object';
    }
    function isFunction(arg) {
        return typeOf(arg) === 'Function';
    }
    function isString(arg) {
        return typeOf(arg) === 'String';
    }
    function isArray(arg) {
        return Array.isArray(arg);
    }

    function callListener(eventThis, listener, args) {
        try {
            listener.apply(eventThis, args);
        }
        catch (e) {
            console.error('EventEmitter.emit()', 'Unexpected listener exception: ' + e + '; stack = ' + (e && e.stack));
        }
    }
    /**
     * Remove listeners that match listener
     * @param targetListeners is an array of listener arrays or event objects with arrays of listeners
     * @param listener the listener callback to remove
     * @param eventFilter (optional) event name instructing the function to only remove listeners for the specified event
     */
    function removeListener(targetListeners, listener, eventFilter) {
        let listeners;
        let index;
        let eventName;
        for (let targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {
            listeners = targetListeners[targetListenersIndex];
            if (eventFilter) {
                listeners = listeners[eventFilter];
            }
            if (isArray(listeners)) {
                while ((index = listeners.indexOf(listener)) !== -1) {
                    listeners.splice(index, 1);
                }
                /* If events object has an event name key with no listeners then
                           remove the key to stop the list growing indefinitely */
                if (eventFilter && listeners.length === 0) {
                    delete targetListeners[targetListenersIndex][eventFilter];
                }
            }
            else if (isObject(listeners)) {
                for (eventName in listeners) {
                    if (Object.prototype.hasOwnProperty.call(listeners, eventName) && isArray(listeners[eventName])) {
                        removeListener([listeners], listener, eventName);
                    }
                }
            }
        }
    }
    // Equivalent of Platform.config.inspect from ably-js for browser/RN
    function inspect(args) {
        return JSON.stringify(args);
    }
    class InvalidArgumentError extends Error {
        constructor(...args) {
            super(...args);
        }
    }
    class EventEmitter {
        constructor() {
            this.any = [];
            this.events = Object.create(null);
            this.anyOnce = [];
            this.eventsOnce = Object.create(null);
        }
        /**
         * Add an event listener
         * @param listenerOrEvents (optional) the name of the event to listen to or the listener to be called.
         * @param listener (optional) the listener to be called.
         */
        on(listenerOrEvents, listener) {
            // .on(() => {})
            if (isFunction(listenerOrEvents)) {
                this.any.push(listenerOrEvents);
                return;
            }
            // .on("eventName", () => {})
            if (isString(listenerOrEvents) && isFunction(listener)) {
                const listeners = this.events[listenerOrEvents] || (this.events[listenerOrEvents] = []);
                listeners.push(listener);
                return;
            }
            // .on(["eventName"], () => {})
            if (isArray(listenerOrEvents) && isFunction(listener)) {
                listenerOrEvents.forEach((eventName) => {
                    this.on(eventName, listener);
                });
                return;
            }
            throw new InvalidArgumentError('EventEmitter.on(): Invalid arguments: ' + inspect([listenerOrEvents, listener]));
        }
        /**
         * Remove one or more event listeners
         * @param listenerOrEvents (optional) the name of the event whose listener is to be removed. If not supplied,
         * the listener is treated as an 'any' listener.
         * @param listener (optional) the listener to remove. If not supplied, all listeners are removed.
         */
        off(listenerOrEvents, listener) {
            // .off()
            // don't use arguments.length === 0 here as don't won't handle
            // cases like .off(undefined) which is a valid call
            if (!listenerOrEvents && !listener) {
                this.any = [];
                this.events = Object.create(null);
                this.anyOnce = [];
                this.eventsOnce = Object.create(null);
                return;
            }
            // .off(() => {})
            if (isFunction(listenerOrEvents)) {
                removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listenerOrEvents);
                return;
            }
            // .off("eventName", () => {})
            if (isString(listenerOrEvents) && isFunction(listener)) {
                removeListener([this.events, this.eventsOnce], listener, listenerOrEvents);
                return;
            }
            // .off("eventName")
            if (isString(listenerOrEvents)) {
                delete this.events[listenerOrEvents];
                delete this.eventsOnce[listenerOrEvents];
                return;
            }
            // .off(["eventName"], () => {})
            if (isArray(listenerOrEvents) && isFunction(listener)) {
                listenerOrEvents.forEach((eventName) => {
                    this.off(eventName, listener);
                });
                return;
            }
            // .off(["eventName"])
            if (isArray(listenerOrEvents)) {
                listenerOrEvents.forEach((eventName) => {
                    this.off(eventName);
                });
                return;
            }
            throw new InvalidArgumentError('EventEmitter.off(): invalid arguments:' + inspect([listenerOrEvents, listener]));
        }
        /**
         * Get the array of listeners for a given event; excludes once events
         * @param event (optional) the name of the event, or none for 'any'
         * @return array of events, or null if none
         */
        listeners(event) {
            var _a;
            if (event) {
                const listeners = [...((_a = this.events[event]) !== null && _a !== void 0 ? _a : [])];
                if (isArray(this.eventsOnce[event])) {
                    Array.prototype.push.apply(listeners, this.eventsOnce[event]);
                }
                return listeners.length ? listeners : null;
            }
            return this.any.length ? this.any : null;
        }
        /**
         * Emit an event
         * @param event the event name
         * @param args the arguments to pass to the listener
         */
        emit(event, ...args /* , args... */) {
            const eventThis = { event };
            const listeners = [];
            if (this.anyOnce.length > 0) {
                Array.prototype.push.apply(listeners, this.anyOnce);
                this.anyOnce = [];
            }
            if (this.any.length > 0) {
                Array.prototype.push.apply(listeners, this.any);
            }
            const eventsOnceListeners = this.eventsOnce[event];
            if (eventsOnceListeners) {
                Array.prototype.push.apply(listeners, eventsOnceListeners);
                delete this.eventsOnce[event];
            }
            const eventsListeners = this.events[event];
            if (eventsListeners) {
                Array.prototype.push.apply(listeners, eventsListeners);
            }
            listeners.forEach(function (listener) {
                callListener(eventThis, listener, args);
            });
        }
        /**
         * Listen for a single occurrence of an event
         * @param listenerOrEvents (optional) the name of the event to listen to
         * @param listener (optional) the listener to be called
         */
        once(listenerOrEvents, listener) {
            // .once("eventName", () => {})
            if (isString(listenerOrEvents) && isFunction(listener)) {
                const listeners = this.eventsOnce[listenerOrEvents] || (this.eventsOnce[listenerOrEvents] = []);
                listeners.push(listener);
                return;
            }
            // .once(["eventName"], () => {})
            if (isArray(listenerOrEvents) && isFunction(listener)) {
                const self = this;
                listenerOrEvents.forEach(function (eventName) {
                    const listenerWrapper = function (listenerThis) {
                        const innerArgs = Array.prototype.slice.call(arguments);
                        listenerOrEvents.forEach((eventName) => {
                            self.off(eventName, this);
                        });
                        listener.apply(listenerThis, innerArgs);
                    };
                    self.once(eventName, listenerWrapper);
                });
                return;
            }
            // .once(() => {})
            if (isFunction(listenerOrEvents)) {
                this.anyOnce.push(listenerOrEvents);
                return;
            }
            throw new InvalidArgumentError('EventEmitter.once(): invalid arguments:' + inspect([listenerOrEvents, listener]));
        }
        /**
         * Private API
         *
         * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState
         * @param targetState the name of the state event to listen to
         * @param currentState the name of the current state of this object
         * @param listener the listener to be called
         * @param listenerArgs
         */
        whenState(targetState, currentState, listener, ...listenerArgs) {
            const eventThis = { event: targetState };
            if (typeof targetState !== 'string' || typeof currentState !== 'string') {
                throw 'whenState requires a valid event String argument';
            }
            if (typeof listener !== 'function' && Promise) {
                return new Promise((resolve) => {
                    EventEmitter.prototype.whenState.apply(this, [targetState, currentState, resolve].concat(listenerArgs));
                });
            }
            if (targetState === currentState) {
                callListener(eventThis, listener, listenerArgs);
            }
            else {
                this.once(targetState, listener);
            }
        }
    }

    const SPACE_CHANNEL_PREFIX = '_ably_space_';
    const CURSOR_UPDATE = 'cursorUpdate';
    const LOCATION_UPDATE = 'locationUpdate';
    const MEMBERS_UPDATE = 'membersUpdate';
    const OUTGOING_BATCH_TIME_DEFAULT = 100;
    const PAGINATION_LIMIT_DEFAULT = 5;

    class Locations extends EventEmitter {
        constructor(space, channel) {
            super();
            this.space = space;
            this.channel = channel;
            this.channel.presence.subscribe(this.onPresenceUpdate.bind(this));
        }
        onPresenceUpdate(message) {
            if (!['update', 'leave'].includes(message.action))
                return;
            const member = this.space.getMemberFromConnection(message.connectionId);
            if (member) {
                const { previousLocation, currentLocation } = message.data;
                member.location = currentLocation;
                this.emit(LOCATION_UPDATE, { member: { ...member }, currentLocation, previousLocation });
            }
        }
        set(location) {
            const self = this.space.getSelf();
            if (!self) {
                throw new Error('Must enter a space before setting a location');
            }
            return this.channel.presence.update({
                profileData: self.profileData,
                previousLocation: self.location,
                currentLocation: location,
            });
        }
        subscribe(listenerOrEvents, listener) {
            try {
                super.on(listenerOrEvents, listener);
            }
            catch (e) {
                if (e instanceof InvalidArgumentError) {
                    throw new InvalidArgumentError('Locations.subscribe(): Invalid arguments: ' + inspect([listenerOrEvents, listener]));
                }
                else {
                    throw e;
                }
            }
        }
        unsubscribe(listenerOrEvents, listener) {
            try {
                super.off(listenerOrEvents, listener);
            }
            catch (e) {
                if (e instanceof InvalidArgumentError) {
                    throw new InvalidArgumentError('Locations.unsubscribe(): Invalid arguments: ' + inspect([listenerOrEvents, listener]));
                }
                else {
                    throw e;
                }
            }
        }
        getSelf() {
            const self = this.space.getSelf();
            return self ? self.location : undefined;
        }
        getOthers() {
            const self = this.space.getSelf();
            return this.space
                .getMembers()
                .filter((member) => member.connectionId !== (self === null || self === void 0 ? void 0 : self.connectionId))
                .reduce((acc, member) => {
                acc[member.connectionId] = member.location;
                return acc;
            }, {});
        }
        getAll() {
            return this.space.getMembers().reduce((acc, member) => {
                acc[member.connectionId] = member.location;
                return acc;
            }, {});
        }
    }

    class CursorBatching {
        constructor(outboundBatchInterval) {
            this.outboundBatchInterval = outboundBatchInterval;
            this.outgoingBuffers = [];
            // Set to `true` when a cursor position is in the buffer
            this.hasMovement = false;
            // Set to `true` when the buffer is actively being emptied
            this.isRunning = false;
            // Set to `true` if there is more than one user listening to cursors
            this.shouldSend = false;
            this.batchTime = outboundBatchInterval;
        }
        pushCursorPosition(channel, cursor) {
            // Ignore the cursor update if there is no one listening
            if (!this.shouldSend)
                return;
            this.hasMovement = true;
            this.pushToBuffer(cursor);
            this.publishFromBuffer(channel, CURSOR_UPDATE);
        }
        setShouldSend(shouldSend) {
            this.shouldSend = shouldSend;
        }
        setBatchTime(batchTime) {
            this.batchTime = batchTime;
        }
        pushToBuffer(value) {
            this.outgoingBuffers.push(value);
        }
        async publishFromBuffer(channel, eventName) {
            if (!this.isRunning) {
                this.isRunning = true;
                await this.batchToChannel(channel, eventName);
            }
        }
        async batchToChannel(channel, eventName) {
            if (!this.hasMovement) {
                this.isRunning = false;
                return;
            }
            // Must be copied here to avoid a race condition where the buffer is cleared before the publish happens
            const bufferCopy = [...this.outgoingBuffers];
            channel.publish(eventName, bufferCopy);
            setTimeout(() => this.batchToChannel(channel, eventName), this.batchTime);
            this.outgoingBuffers = [];
            this.hasMovement = false;
            this.isRunning = true;
        }
    }

    function clamp(num, min, max) {
        return Math.min(Math.max(num, min), max);
    }

    class CursorDispensing {
        constructor(emitCursorUpdate, getCurrentBatchTime) {
            this.buffer = {};
            this.handlerRunning = false;
            this.timerIds = [];
            this.emitCursorUpdate = emitCursorUpdate;
            this.getCurrentBatchTime = getCurrentBatchTime;
        }
        emitFromBatch(batchDispenseInterval) {
            if (!this.bufferHaveData()) {
                this.handlerRunning = false;
                return;
            }
            this.handlerRunning = true;
            const processBuffer = () => {
                for (let connectionId in this.buffer) {
                    const buffer = this.buffer[connectionId];
                    const update = buffer.shift();
                    if (!update)
                        continue;
                    this.emitCursorUpdate(update);
                }
                if (this.bufferHaveData()) {
                    this.emitFromBatch(this.calculateDispenseInterval());
                }
                else {
                    this.handlerRunning = false;
                }
                this.timerIds.shift();
            };
            if (typeof document !== 'undefined' && document.visibilityState === 'hidden') {
                this.timerIds.forEach((id) => clearTimeout(id));
                this.timerIds = [];
                processBuffer();
            }
            else {
                this.timerIds.push(setTimeout(processBuffer, batchDispenseInterval));
            }
        }
        bufferHaveData() {
            return (Object.entries(this.buffer)
                .map(([, v]) => v)
                .flat().length > 0);
        }
        calculateDispenseInterval() {
            const bufferLengths = Object.entries(this.buffer).map(([, v]) => v.length);
            const highest = bufferLengths.sort()[bufferLengths.length - 1];
            const finalOutboundBatchInterval = this.getCurrentBatchTime();
            return Math.floor(clamp(finalOutboundBatchInterval / highest, 1, 1000 / 15));
        }
        processBatch(message) {
            const updates = message.data || [];
            updates.forEach((update) => {
                const enhancedMsg = {
                    clientId: message.clientId,
                    connectionId: message.connectionId,
                    position: update.position,
                    data: update.data,
                };
                if (this.buffer[enhancedMsg.connectionId]) {
                    this.buffer[enhancedMsg.connectionId].push(enhancedMsg);
                }
                else {
                    this.buffer[enhancedMsg.connectionId] = [enhancedMsg];
                }
            });
            if (!this.handlerRunning && this.bufferHaveData()) {
                this.emitFromBatch(this.calculateDispenseInterval());
            }
        }
    }

    class CursorHistory {
        constructor() { }
        positionsMissing(connections) {
            return Object.keys(connections).some((connectionId) => connections[connectionId] === null);
        }
        messageToUpdate(connectionId, clientId, update) {
            return {
                clientId,
                connectionId,
                position: update.position,
                data: update.data,
            };
        }
        allCursorUpdates(connections, page) {
            return Object.fromEntries(Object.entries(connections).map(([connectionId, cursors]) => {
                const lastMessage = page.items.find((item) => item.connectionId === connectionId);
                if (!lastMessage)
                    return [connectionId, cursors];
                const { data, clientId } = lastMessage;
                const lastUpdate = (data === null || data === void 0 ? void 0 : data.length) > 0 ? this.messageToUpdate(connectionId, clientId, data[data.length - 1]) : null;
                return [connectionId, lastUpdate];
            }));
        }
        async getLastCursorUpdate(channel, paginationLimit) {
            const members = await channel.presence.get();
            if (members.length === 0)
                return {};
            let connections = members.reduce((acc, member) => ({
                ...acc,
                [member.connectionId]: null,
            }), {});
            const history = await channel.history();
            let pageNo = 1;
            let page = await history.current();
            connections = this.allCursorUpdates(connections, page);
            pageNo++;
            while (pageNo <= paginationLimit && this.positionsMissing(connections) && history.hasNext()) {
                page = await history.next();
                connections = this.allCursorUpdates(connections, page);
                pageNo++;
            }
            return connections;
        }
    }

    const emitterHasListeners = (emitter) => {
        const flattenEvents = (obj) => Object.entries(obj)
            .map((_, v) => v)
            .flat();
        return (emitter.any.length > 0 ||
            emitter.anyOnce.length > 0 ||
            flattenEvents(emitter.events).length > 0 ||
            flattenEvents(emitter.eventsOnce).length > 0);
    };
    class Cursors extends EventEmitter {
        constructor(space, options = {}) {
            var _a, _b;
            super();
            this.space = space;
            this.options = {
                outboundBatchInterval: (_a = options['outboundBatchInterval']) !== null && _a !== void 0 ? _a : OUTGOING_BATCH_TIME_DEFAULT,
                paginationLimit: (_b = options['paginationLimit']) !== null && _b !== void 0 ? _b : PAGINATION_LIMIT_DEFAULT,
            };
            this.cursorHistory = new CursorHistory();
            this.cursorBatching = new CursorBatching(this.options.outboundBatchInterval);
            const emitCursorUpdate = (update) => this.emit('cursorsUpdate', update);
            const getCurrentBatchTime = () => this.cursorBatching.batchTime;
            this.cursorDispensing = new CursorDispensing(emitCursorUpdate, getCurrentBatchTime);
        }
        /**
         * Schedules a cursor update event to be sent that will cause the following events to fire
         *
         * @param {CursorUpdate} cursor
         * @return {void}
         */
        set(cursor) {
            const self = this.space.getSelf();
            if (!self) {
                throw new Error('Must enter a space before setting a cursor update');
            }
            const channel = this.getChannel();
            this.cursorBatching.pushCursorPosition(channel, cursor);
        }
        getChannel() {
            var _a;
            return (_a = this.channel) !== null && _a !== void 0 ? _a : (this.channel = this.initializeCursorsChannel());
        }
        initializeCursorsChannel() {
            const spaceChannelName = this.space.getChannelName();
            const channel = this.space.client.channels.get(`${spaceChannelName}_cursors`);
            channel.presence.subscribe(this.onPresenceUpdate.bind(this));
            channel.presence.enter();
            return channel;
        }
        async onPresenceUpdate() {
            const channel = this.getChannel();
            const cursorsMembers = await channel.presence.get();
            this.cursorBatching.setShouldSend(cursorsMembers.length > 1);
            this.cursorBatching.setBatchTime((cursorsMembers.length - 1) * this.options.outboundBatchInterval);
        }
        isUnsubscribed() {
            const channel = this.getChannel();
            return !emitterHasListeners(channel['subscriptions']);
        }
        subscribe(listenerOrEvents, listener) {
            try {
                super.on(listenerOrEvents, listener);
            }
            catch (e) {
                if (e instanceof InvalidArgumentError) {
                    throw new InvalidArgumentError('Cursors.subscribe(): Invalid arguments: ' + inspect([listenerOrEvents, listener]));
                }
                else {
                    throw e;
                }
            }
            if (this.isUnsubscribed()) {
                const channel = this.getChannel();
                channel.subscribe(CURSOR_UPDATE, (message) => {
                    this.cursorDispensing.processBatch(message);
                });
            }
        }
        unsubscribe(listenerOrEvents, listener) {
            try {
                super.off(listenerOrEvents, listener);
            }
            catch (e) {
                if (e instanceof InvalidArgumentError) {
                    throw new InvalidArgumentError('Cursors.unsubscribe(): Invalid arguments: ' + inspect([listenerOrEvents, listener]));
                }
                else {
                    throw e;
                }
            }
            const hasListeners = emitterHasListeners(this);
            if (!hasListeners) {
                const channel = this.getChannel();
                channel.unsubscribe();
            }
        }
        async getAll() {
            const channel = this.getChannel();
            return await this.cursorHistory.getLastCursorUpdate(channel, this.options.paginationLimit);
        }
    }

    const SPACE_OPTIONS_DEFAULTS = {
        offlineTimeout: 120000,
    };
    class Space extends EventEmitter {
        constructor(name, client, options) {
            super();
            this.name = name;
            this.client = client;
            this.options = { ...SPACE_OPTIONS_DEFAULTS, ...options };
            this.connectionId = this.client.connection.id;
            this.members = [];
            this.leavers = [];
            this.onPresenceUpdate = this.onPresenceUpdate.bind(this);
            this.setChannel(this.name);
            this.locations = new Locations(this, this.channel);
            this.cursors = new Cursors(this, options === null || options === void 0 ? void 0 : options.cursors);
        }
        setChannel(rootName) {
            // Remove the old subscription if the channel is switching
            if (this.channel) {
                this.channel.presence.unsubscribe(this.onPresenceUpdate);
            }
            this.channelName = `${SPACE_CHANNEL_PREFIX}${rootName}`;
            this.channel = this.client.channels.get(this.channelName);
            this.channel.presence.subscribe(this.onPresenceUpdate);
        }
        getChannelName() {
            return this.channelName;
        }
        getMemberFromConnection(connectionId) {
            return this.members.find((m) => m.connectionId === connectionId);
        }
        getMemberIndexFromConnection(connectionId) {
            return this.members.findIndex((m) => m.connectionId === connectionId);
        }
        updateOrCreateMember(message) {
            var _a, _b, _c;
            const member = this.getMemberFromConnection(message.connectionId);
            const lastEvent = {
                name: message.action,
                timestamp: message.timestamp,
            };
            if (!member) {
                return {
                    clientId: message.clientId,
                    connectionId: message.connectionId,
                    isConnected: message.action !== 'leave',
                    profileData: message.data.profileData,
                    location: ((_a = message === null || message === void 0 ? void 0 : message.data) === null || _a === void 0 ? void 0 : _a.currentLocation) || null,
                    lastEvent,
                };
            }
            member.isConnected = message.action !== 'leave';
            member.lastEvent = lastEvent;
            member.profileData = (_c = (_b = message.data) === null || _b === void 0 ? void 0 : _b.profileData) !== null && _c !== void 0 ? _c : member.profileData;
            return member;
        }
        mapPresenceMembersToSpaceMembers(messages) {
            return messages.map((message) => this.updateOrCreateMember(message));
        }
        addLeaver(message) {
            const timeoutCallback = () => {
                const member = this.getMemberFromConnection(message.connectionId);
                this.emit('leave', member);
                this.removeMember(message.connectionId);
                this.emit(MEMBERS_UPDATE, this.members);
                if (member === null || member === void 0 ? void 0 : member.location) {
                    this.locations.emit(LOCATION_UPDATE, {
                        previousLocation: member.location,
                        currentLocation: null,
                        member: { ...member, location: null },
                    });
                }
            };
            this.leavers.push({
                clientId: message.clientId,
                connectionId: message.connectionId,
                timeoutId: setTimeout(timeoutCallback, this.options.offlineTimeout),
            });
        }
        removeLeaver(leaverIndex) {
            clearTimeout(this.leavers[leaverIndex].timeoutId);
            this.leavers.splice(leaverIndex, 1);
        }
        updateLeavers(message) {
            const index = this.leavers.findIndex(({ connectionId }) => message.connectionId === connectionId);
            if (message.action === 'leave' && index < 0) {
                this.addLeaver(message);
            }
            else if (message.action === 'leave' && index >= 0) {
                this.removeLeaver(index);
                this.addLeaver(message);
            }
            else if (index >= 0) {
                this.removeLeaver(index);
            }
        }
        updateMembers(message) {
            const index = this.getMemberIndexFromConnection(message.connectionId);
            const spaceMember = this.updateOrCreateMember(message);
            if (index >= 0) {
                this.emit('update', spaceMember);
                this.members[index] = spaceMember;
            }
            else {
                this.emit('enter', spaceMember);
                this.members.push(spaceMember);
            }
        }
        removeMember(connectionId) {
            const index = this.getMemberIndexFromConnection(connectionId);
            if (index >= 0) {
                this.members.splice(index, 1);
            }
        }
        onPresenceUpdate(message) {
            if (!message)
                return;
            this.updateLeavers(message);
            this.updateMembers(message);
            this.emit(MEMBERS_UPDATE, this.members);
        }
        async enter(profileData) {
            return new Promise((resolve) => {
                const presence = this.channel.presence;
                presence.enter({ profileData });
                presence['subscriptions'].once('enter', async () => {
                    const presenceMessages = await presence.get();
                    this.members = this.mapPresenceMembersToSpaceMembers(presenceMessages);
                    resolve(this.members);
                });
            });
        }
        async updateProfileData(profileDataOrUpdateFn) {
            const self = this.getSelf();
            if (isFunction(profileDataOrUpdateFn) && !self) {
                const update = profileDataOrUpdateFn();
                await this.enter(update);
                return;
            }
            else if (!self) {
                await this.enter(profileDataOrUpdateFn);
                return;
            }
            else if (isFunction(profileDataOrUpdateFn) && self) {
                const update = profileDataOrUpdateFn(self.profileData);
                await this.channel.presence.update({ profileData: update });
                return;
            }
            await this.channel.presence.update({ profileData: profileDataOrUpdateFn });
            return;
        }
        leave(profileData) {
            return this.channel.presence.leave({ profileData });
        }
        getMembers() {
            return this.members;
        }
        getSelf() {
            if (this.connectionId) {
                return this.getMemberFromConnection(this.connectionId);
            }
            return;
        }
        subscribe(listenerOrEvents, listener) {
            try {
                super.on(listenerOrEvents, listener);
            }
            catch (e) {
                if (e instanceof InvalidArgumentError) {
                    throw new InvalidArgumentError('Space.subscribe(): Invalid arguments: ' + inspect([listenerOrEvents, listener]));
                }
                else {
                    throw e;
                }
            }
        }
        unsubscribe(listenerOrEvents, listener) {
            try {
                super.off(listenerOrEvents, listener);
            }
            catch (e) {
                if (e instanceof InvalidArgumentError) {
                    throw new InvalidArgumentError('Space.unsubscribe(): Invalid arguments: ' + inspect([listenerOrEvents, listener]));
                }
                else {
                    throw e;
                }
            }
        }
    }

    class Spaces {
        constructor(optionsOrAbly) {
            this.version = '0.0.12';
            this.spaces = {};
            if (optionsOrAbly['options']) {
                this.ably = optionsOrAbly;
                this.addAgent(this.ably['options'], false);
            }
            else {
                let options = typeof optionsOrAbly === 'string' ? { key: optionsOrAbly } : optionsOrAbly;
                this.addAgent(options, true);
                this.ably = new Ably__namespace.Realtime.Promise(options);
            }
            this.ably.time();
        }
        addAgent(options, isDefault) {
            var _a;
            const agent = { 'ably-spaces': this.version, [isDefault ? 'space-default-client' : 'space-custom-client']: true };
            options.agents = { ...((_a = options.agents) !== null && _a !== void 0 ? _a : options.agents), ...agent };
        }
        async get(name, options) {
            if (typeof name !== 'string' || name.length === 0) {
                throw new Error('Spaces must have a non-empty name');
            }
            if (this.spaces[name])
                return this.spaces[name];
            if (this.ably.connection.state !== 'connected') {
                await this.ably.connection.once('connected');
            }
            const space = new Space(name, this.ably, options);
            this.spaces[name] = space;
            return space;
        }
    }

    return Spaces;

})(Ably);
